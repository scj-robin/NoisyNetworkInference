############################################################
############ Fonctions de bases à utiliser dans R ####################
############ Ex : "Main_function_last" ####################
############ Manipulation de vecteurs, etc ####################
############################################################

#############################################################
#Construit une matrice symétrique à partir d'un vecteur
#############################################################
vect_mat_low <- function(V, diag=F)
{
  N <- length(V)
  if(diag == F) {n <- (1+sqrt(1+8*N))/2} else{ n <- (-1+sqrt(1+8*N))/2}
  M <- matrix(0,n,n) 
  M[lower.tri(M, diag=diag)] <- V
  B <- t(M)
  diag(B) <- 0
  M <- B + M
  return(M)
}

###########################################################################
#Construit un vecteur à partir d'une matrice triangulaire inférieure
###########################################################################
mat_vect_low <- function(M, diag=F)
{
  V <- M[lower.tri(M, diag = diag)]
  return(V)
}

############################################################################
#Passage d'une matrice binaire à un vecteur des indices 
############################################################################
mat_bin_to_vect_ind <- function(n,pi_melange)
{
  Z_m <- rmultinom(n, size = 1, prob = pi_melange)
  Z_v <- which(Z_m == 1, 1)
  Z_v <- Z_v[,1] 
  return(Z_v, Z_m)
}


###########################################################################
#recuperer les indices de la matrice triangulaire inferieure 
###########################################################################

indices <- function(n, diag=F)
{
  N  <- (n * (n-1)/2)*(diag==F) +(n * (n+1)/2)*(diag==T)
  S <- vect_mat_low(c(1:N), diag=diag)
  S[upper.tri(S)]=0
  return(which(S!=0,arr.ind=T))
}

#############################################################################
#############################################################################
# Indice_mat <- function(n)
# {
#   N  <- n * (n-1)/2
#   S=matrix(1:n^2, ncol=n)
#   V <- S[lower.tri(S, diag = F)]
#   j <- (V%/%(n+1))+1
#   i <- V%%n
#   i[which(i==0)]<-n
#   return(cbind(matrix(c(i,j),ncol=2)))
# }

#############################################################################
#############################################################################
Indice_mat <- function(n,V)
{
  i <- (V-1)%/%n +1
  j <- V%%n + n * ((V%%n)==0)
  return(cbind(matrix(c(i,j),ncol=2)))
}

############################################################################
#passer de n à N et inversement:
############################################################################
#N <- n*(n-1)/2
#n <-(1+sqrt(1+8*N))/2

#############################################################################
#############################################################################
fun_test<-function(a_i_b_i){
  return(exp(seq(log(a_i_b_i["a"]),log(a_i_b_i["b"]),length.out = a_i_b_i["k"])))
}
#############################################################################
#############################################################################

